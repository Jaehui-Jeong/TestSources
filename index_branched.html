<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <title>GLTF Viewer - AI 기반 누출 탐지 시스템</title>
  <style>
    body {
      margin: 0;
      font-family: 'Inter', 'Arial', sans-serif;
      overflow: hidden;
      background-color: #121212;
      color: #E0E0E0;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .right-panel {
      flex-grow: 1;
      background: #1A1D2E;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #overlay-buttons {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      display: flex;
      gap: 10px;
    }

    #overlay-buttons button {
      padding: 10px 20px;
      font-size: 0.9rem;
      font-weight: 500;
      color: #00CFE8;
      background: transparent;
      border: 1px solid #00CFE8;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #overlay-buttons button:hover {
      background: rgba(0, 207, 232, 0.1);
      box-shadow: 0 0 15px rgba(0, 207, 232, 0.3);
    }

    #overlay-buttons button.active {
      background: #00CFE8;
      color: #1A1D2E;
      box-shadow: 0 0 15px rgba(0, 207, 232, 0.5);
    }

    #popup {
      position: fixed;
      display: none;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(26, 29, 46, 0.88);
      backdrop-filter: blur(12px) saturate(190%);
      -webkit-backdrop-filter: blur(12px) saturate(190%);
      border: 1px solid rgba(0, 207, 232, 0.25);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 207, 232, 0.2);
      font-size: 14px;
      z-index: 9999;
      width: 50vw;
      min-width: 250px;
      overflow: auto;
      max-height: 80vh;
    }

    #popup-header {
      cursor: move;
      background: rgba(26, 29, 46, 0.7);
      padding: 10px 15px;
      border-bottom: 1px solid rgba(0, 207, 232, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 16px 16px 0 0;
    }

    #popup-header button {
      background: transparent;
      color: #00CFE8;
      border: 1px solid #00CFE8;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      font-size: 14px;
      line-height: 26px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    #popup-header button:hover {
      background: rgba(0, 207, 232, 0.2);
      color: #FFFFFF;
      box-shadow: 0 0 10px rgba(0, 207, 232, 0.5);
    }

    #popup-content {
      width: 90%;
      padding: 15px;
      margin: 0 auto;
    }

    #info-panel {
      position: absolute;
      top: 80px;
      left: 20px;
      max-width: 300px;
      background: rgba(26, 29, 46, 0.88);
      backdrop-filter: blur(12px) saturate(190%);
      -webkit-backdrop-filter: blur(12px) saturate(190%);
      border: 1px solid rgba(0, 207, 232, 0.25);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 207, 232, 0.2);
      padding: 20px;
      color: #E0E0E0;
      font-size: 0.85rem;
      z-index: 100;
    }

    #info-panel h2 {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: #00CFE8;
      border-bottom: 1px solid rgba(0, 207, 232, 0.3);
      padding-bottom: 10px;
    }

    #info-panel p {
      margin-bottom: 8px;
      line-height: 1.5;
    }

    #info-panel ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #info-panel li {
      margin-bottom: 5px;
    }

    #info-panel span {
      font-weight: 500;
      color: #FFFFFF;
    }

    .sensor-label {
      color: #E0E0E0;
      background-color: rgba(26, 29, 46, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      position: absolute;
      transform: translateX(-50%) translateY(-160%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(0, 207, 232, 0.3);
      z-index: 1;
    }

    #sensorChart {
      width: 100%;
      height: 100%;
      min-height: 300px;
    }

    .chart-container {
      width: 100%;
      height: auto;
      margin-top: 10px;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="right-panel" id="viewer"></div>
  </div>

  <div id="overlay-buttons">
    <button onclick="LearningStart()">AI 학습</button>
    <button onclick="DemoStart()">데모 시작</button>
    <button onclick="LeakDetection()">AI 기반 누출 추정</button>
    <button onclick="Dispersion()">암모니아 확산 양상</button>
  </div>

  <div id="info-panel">
    <h2>시뮬레이션 정보</h2>
    <p>현재 데모: <span id="currentDemo">대기 중</span></p>
    <p id="sensorInfo">센서를 클릭하면 정보가 표시됩니다.</p>
    <div id="sensorList"></div>
  </div>

  <div id="popup">
    <div id="popup-header">
      <span><strong id="popup-title">정보</strong></span>
      <button onclick="popup.style.display='none'; popupLocked=false;">✖</button>
    </div>
    <div id="popup-content"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    let scene, camera, renderer, loader, controls, currentModel;
    const popup = document.getElementById('popup');
    const popupHeader = document.getElementById('popup-header');
    const popupTitle = document.getElementById('popup-title');
    const currentDemoDisplay = document.getElementById('currentDemo');
    let popupLocked = false;  // 팝업 잠금 여부

    init();
    loadModel('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/model_GE-v1.glb');

    function init() {
      const container = document.getElementById('viewer');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1A1D2E);  // 어두운 파란색 배경으로 변경
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      const aspect = container.clientWidth / container.clientHeight;
      const dist = 15;
      camera = new THREE.OrthographicCamera(-dist * aspect, dist * aspect, dist, -dist, 0.1, 1000);
      camera.position.set(0, 0, -dist);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      loader = new THREE.GLTFLoader();

      // 향상된 조명 설정
      scene.add(new THREE.AmbientLight(0xaaaaaa, 0.7));
      const dirLight = new THREE.DirectionalLight(0x00CFE8, 0.5); // 사이언 컬러 강조
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);
      
      const pointLight = new THREE.PointLight(0xffffff, 0.3);
      pointLight.position.set(-5, -5, -5);
      scene.add(pointLight);

      animate();
      resetUI();
    }

    function resetUI() {
      // UI 상태 초기화
      currentDemoDisplay.textContent = "대기 중";
      document.getElementById('sensorInfo').textContent = "센서를 클릭하면 정보가 표시됩니다.";
      document.getElementById('sensorList').innerHTML = "";
      
      // 기존 버튼 스타일 초기화
      const buttons = document.querySelectorAll('#overlay-buttons button');
      buttons.forEach(btn => btn.classList.remove('active'));
    }

    function loadModel(path) {
      if (currentModel) scene.remove(currentModel);
      
      loader.load(path, function (gltf) {
        currentModel = gltf.scene;
        
        // 모델 가시성 향상을 위한 설정
        currentModel.traverse(function(child) {
          if (child.isMesh) {
            // 기존 재질을 향상된 재질로 교체
            const origMaterial = child.material;
            const enhancedMaterial = new THREE.MeshStandardMaterial({
              color: origMaterial.color || 0xCCCCCC,
              metalness: 0.3,
              roughness: 0.6,
              emissive: 0x222222,
              emissiveIntensity: 0.2
            });
            child.material = enhancedMaterial;
          }
        });
        
        scene.add(currentModel);
      }, undefined, function (error) {
        console.error('모델 로드 실패:', error);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
      
      // 라벨 위치 업데이트
      updateLabels();
    }

    function updateLabels() {
      // 라벨 있는 모든 요소 업데이트 (상태 큐브, 센서 등)
      document.querySelectorAll('.sensor-label').forEach(label => {
        const id = label.getAttribute('data-id');
        if (!id) return;
        
        const object = scene.getObjectByName(id);
        if (object) {
          const vector = object.position.clone().project(camera);
          const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
          const y = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
          label.style.left = `${x}px`;
          label.style.top = `${y}px`;
          label.style.display = vector.z < 1 ? 'block' : 'none';
        }
      });
    }

    // 장비 상태 정육면체 생성 함수
    function addStatusCubeAt(x, y, z, name) {
      // 기존 객체 있으면 제거
      const existingCube = scene.getObjectByName(name);
      if (existingCube) {
        scene.remove(existingCube);
      }
      
      const geometry = new THREE.BoxGeometry(2, 10, 3);
      const material = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.5,
        emissive: 0x003300,
        emissiveIntensity: 0.2
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y, z);
      cube.name = name;
      scene.add(cube);
      
      // 라벨 추가
      const labelDiv = document.createElement('div');
      labelDiv.className = 'sensor-label';
      labelDiv.textContent = name;
      labelDiv.setAttribute('data-id', name);
      document.body.appendChild(labelDiv);
      
      return cube;
    }

    const clickableCubes = [];
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let INTERSECTED = null;

    // 라벨 큐브 생성
    function addLabeledCube(x, y, z, name, size = 1, imagePath = null) {
      // 기존에 있으면 제거
      const existingCube = scene.getObjectByName(name);
      if (existingCube) {
        scene.remove(existingCube);
        clickableCubes.splice(clickableCubes.indexOf(existingCube), 1);
      }
      
      const geometry = new THREE.BoxGeometry(size, size, size);
      const material = new THREE.MeshStandardMaterial({
        color: 0x00CFE8,
        transparent: true,
        opacity: 0.7,
        emissive: 0x006774,
        emissiveIntensity: 0.3
      });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y, z);
      cube.userData.name = name;
      cube.userData.image = imagePath;
      cube.name = name;
      scene.add(cube);
      clickableCubes.push(cube);

      // 라벨
      const labelDiv = document.createElement('div');
      labelDiv.className = 'sensor-label';
      labelDiv.textContent = name;
      labelDiv.setAttribute('data-id', name);
      document.body.appendChild(labelDiv);
      
      // 센서 정보 패널에 추가
      const sensorList = document.getElementById('sensorList');
      const sensorItem = document.createElement('div');
      sensorItem.innerHTML = `<p>${name}: <span id="${name.replace(/\s+/g, '')}_value">N/A</span></p>`;
      sensorList.appendChild(sensorItem);
      
      return cube;
    }

    function LearningStart() {
      resetUI();
      document.querySelector('button[onclick="LearningStart()"]').classList.add('active');
      currentDemoDisplay.textContent = "AI 학습";
      
      popupLocked = true;  // AI 학습에서 생성된 팝업은 고정
      popupTitle.textContent = "AI 학습";
      
      const imgPath = "https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png";

      const html = `
      <div style="text-align: center; margin-bottom: 15px;">
        <img src="${imgPath}" alt="AI 학습 이미지" style="width:90%; max-height:300px; object-fit:contain; margin-top:5px; border-radius:8px; border:1px solid rgba(0,207,232,0.3);">
      </div>
      <p style="line-height:1.6;">AI 학습이 진행 중입니다. 누출 패턴 데이터를 분석하고 있습니다.</p>
      <div style="margin-top:15px; background: rgba(0,207,232,0.1); padding:10px; border-radius:8px; border:1px solid rgba(0,207,232,0.2);">
        <h3 style="margin-top:0; color:#00CFE8; font-size:1rem;">학습 진행 상황</h3>
        <p>데이터 포인트: <strong>23,450개</strong></p>
        <p>모델 정확도: <strong>97.2%</strong></p>
        <p>남은 시간: <strong>약 2분</strong></p>
      </div>
    `;

      document.getElementById('popup-content').innerHTML = html;
      popup.style.display = 'block';
    }

    let leakChart;             // Chart.js 인스턴스
    let leakTimer;             // setInterval 타이머
    let leakData = [];         // 전체 데이터 배열
    let leakIndex = 0;         // 현재 시점 인덱스

    function DemoStart() {
      resetUI();
      document.querySelector('button[onclick="DemoStart()"]').classList.add('active');
      currentDemoDisplay.textContent = "데모 시작";
      
      clearInterval(leakTimer);  // 이전 실행 중지
      leakChart?.destroy();      // 기존 그래프 제거
      leakData = [];
      leakIndex = 0;
      popupLocked = true;

      const speedFactor = 5; // ✅ n배 빠르게 (예: 5배 빠르게)

      fetch('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leak_7.csv') 
        .then(response => response.text())
        .then(csvText => {
          const lines = csvText.trim().split('\n');
          const headers = lines[0].split(',');
          const timeIdx = headers.indexOf('Time (sec)');

          // value 컬럼 인덱스들 (value1, value2, ...)
          const valueIndices = headers
            .map((h, i) => ({ name: h.trim(), idx: i }))
            .filter(obj => obj.name !== 'Time (sec)');

          for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',');
            const time = parseFloat(parts[timeIdx]);
            const values = valueIndices.map(obj => parseFloat(parts[obj.idx]));
            leakData.push({ x: time, yValues: values });
          }

          popupTitle.textContent = "실시간 센서 데이터";
          document.getElementById('popup-content').innerHTML = `
            <div class="chart-container">
              <canvas id="leakChart"></canvas>
            </div>
            <div style="margin-top: 15px; font-size: 0.9rem; color: #E0E0E0;">
              <p>현재 시간: <span id="currentTime">0.00</span>초</p>
              <p>최대 농도: <span id="maxConcentration">0.00</span> ppm</p>
            </div>
          `;
          popup.style.display = 'block';

          const ctx = document.getElementById('leakChart').getContext('2d');
          leakChart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: valueIndices.map((obj, index) => ({
                label: obj.name,
                data: [],
                borderColor: `hsl(${(index * 60) % 360}, 70%, 50%)`,
                backgroundColor: `hsla(${(index * 60) % 360}, 70%, 50%, 0.2)`,
                fill: false,
                tension: 0.2,
                pointRadius: 1,
                pointHoverRadius: 3
              }))
            },
            options: {
              animation: false,
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Time [s]', color: '#E0E0E0' },
                  min: 0,
                  grid: { color: 'rgba(0, 207, 232, 0.1)' },
                  ticks: { color: '#B0B0B0' }
                },
                y: {
                  title: { display: true, text: 'NH3 [ppm]', color: '#E0E0E0' },
                  min: 0,
                  grid: { color: 'rgba(0, 207, 232, 0.1)' },
                  ticks: { color: '#B0B0B0' }
                }
              },
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  labels: { color: '#E0E0E0' }
                },
                tooltip: {
                  backgroundColor: 'rgba(26, 29, 46, 0.9)',
                  borderColor: 'rgba(0, 207, 232, 0.3)',
                  borderWidth: 1,
                  titleColor: '#00CFE8',
                  bodyColor: '#E0E0E0',
                  displayColors: true,
                  padding: 10
                }
              }
            }
          });

          // 1초 간격으로 값 추가
          leakTimer = setInterval(() => {
            if (leakIndex < leakData.length) {
              const point = leakData[leakIndex];
              
              document.getElementById('currentTime').textContent = point.x.toFixed(2);
              let maxVal = 0;
              
              point.yValues.forEach((val, idx) => {
                leakChart.data.datasets[idx].data.push({ x: point.x, y: val });
                if (val > maxVal) maxVal = val;
              });
              
              document.getElementById('maxConcentration').textContent = maxVal.toFixed(2);
              
              // 👉 x축 max 값을 현재 시간 + 1로 실시간 업데이트
              leakChart.options.scales.x.max = leakData[leakIndex].x + 1;
              leakChart.update();
              leakIndex++;
            } else {
              clearInterval(leakTimer); // 종료
            }
          }, 1000 / speedFactor);
        })
        .catch(error => {
          popupTitle.textContent = "오류";
          document.getElementById('popup-content').innerHTML = `<p style="color:#ff4d4d;">CSV 로드 실패: ${error}</p>`;
          popup.style.display = 'block';
        });
    }

    function LeakDetection() {
      resetUI();
      document.querySelector('button[onclick="LeakDetection()"]').classList.add('active');
      currentDemoDisplay.textContent = "AI 기반 누출 추정";
      
      clearInterval(leakTimer);
      leakChart?.destroy();
      leakData = [];
      leakIndex = 0;
      popupLocked = true;

      const speedFactor = 5;  // n배 빠르게

      // 상태 큐브 생성
      const statusCube1 = addStatusCubeAt(3.5, -1, 2, 'GE#1');
      const statusCube2 = addStatusCubeAt(-0.4, -1, 2, 'GE#2');
      const statusCube3 = addStatusCubeAt(-4.3, -1, 2, 'GE#3');

      popupTitle.textContent = "AI 누출 추정";
      document.getElementById('popup-content').innerHTML = `
        <div style="margin-bottom: 15px; background: rgba(0,207,232,0.1); padding:10px; border-radius:8px; border:1px solid rgba(0,207,232,0.2);">
          <h3 style="margin-top:0; color:#00CFE8; font-size:1rem;">누출 추정 결과</h3>
          <p>추정 누출 위치: <strong>GE#1</strong></p>
          <p>추정 확률: <strong id="leakProbability">0%</strong></p>
          <p>현재 분석 시간: <strong id="analysisTime">0.00초</strong></p>
        </div>
        <div class="chart-container">
          <canvas id="leakChart"></canvas>
        </div>
      `;
      popup.style.display = 'block';

      fetch('https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/leakDetection.csv') 
        .then(response => response.text())
        .then(csvText => {
          const lines = csvText.trim().split('\n');
          const headers = lines[0].split(',');
          const timeIdx = headers.indexOf('Time (sec)');

          // value 컬럼 인덱스들 (value1, value2, ...)
          const valueIndices = headers
            .map((h, i) => ({ name: h.trim(), idx: i }))
            .filter(obj => obj.name !== 'Time (sec)');

          for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',');
            const time = parseFloat(parts[timeIdx]);
            const values = valueIndices.map(obj => parseFloat(parts[obj.idx]));
            leakData.push({ x: time, yValues: values });
          }

          const ctx = document.getElementById('leakChart').getContext('2d');
          leakChart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: valueIndices.map((obj, index) => ({
                label: obj.name,
                data: [],
                borderColor: `hsl(${(index * 60) % 360}, 70%, 50%)`,
                backgroundColor: `hsla(${(index * 60) % 360}, 70%, 50%, 0.2)`,
                fill: false,
                tension: 0.2,
                pointRadius: 1,
                pointHoverRadius: 3
              }))
            },
            options: {
              animation: false,
              scales: {
                x: {
                  type: 'linear',
                  title: { display: true, text: 'Time [s]', color: '#E0E0E0' },
                  min: 0,
                  grid: { color: 'rgba(0, 207, 232, 0.1)' },
                  ticks: { color: '#B0B0B0' }
                },
                y: {
                  title: { display: true, text: 'NH3 [ppm]', color: '#E0E0E0' },
                  min: 0,
                  grid: { color: 'rgba(0, 207, 232, 0.1)' },
                  ticks: { color: '#B0B0B0' }
                }
              },
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  labels: { color: '#E0E0E0' }
                },
                tooltip: {
                  backgroundColor: 'rgba(26, 29, 46, 0.9)',
                  borderColor: 'rgba(0, 207, 232, 0.3)',
                  borderWidth: 1,
                  titleColor: '#00CFE8',
                  bodyColor: '#E0E0E0',
                  displayColors: true,
                  padding: 10
                }
              }
            }
          });

          // 1초 간격으로 값 추가
          leakTimer = setInterval(() => {
            if (leakIndex < leakData.length) {
              const point = leakData[leakIndex];
              const probability = Math.min(100, Math.floor(point.x * 2.5));
              
              document.getElementById('leakProbability').textContent = `${probability}%`;
              document.getElementById('analysisTime').textContent = `${point.x.toFixed(2)}초`;
              
              point.yValues.forEach((val, idx) => {
                leakChart.data.datasets[idx].data.push({ x: point.x, y: val });
              });
              // 👉 x축 max 값을 현재 시간 + 1로 실시간 업데이트
              leakChart.options.scales.x.max = leakData[leakIndex].x + 1;

              // 동적으로 큐브 색상 업데이트
              const red1 = Math.floor(point.yValues[0] * 255);
              const green1 = Math.floor((1 - point.yValues[0]) * 255);
              statusCube1.material.color.setRGB(red1 / 255, green1 / 255, 0);
              statusCube1.material.emissive.setRGB(red1 / 255 * 0.3, green1 / 255 * 0.3, 0);

              const red2 = Math.floor(point.yValues[1] * 255);
              const green2 = Math.floor((1 - point.yValues[1]) * 255);
              statusCube2.material.color.setRGB(red2 / 255, green2 / 255, 0);
              statusCube2.material.emissive.setRGB(red2 / 255 * 0.3, green2 / 255 * 0.3, 0);

              const red3 = Math.floor(point.yValues[2] * 255);
              const green3 = Math.floor((1 - point.yValues[2]) * 255);
              statusCube3.material.color.setRGB(red3 / 255, green3 / 255, 0);
              statusCube3.material.emissive.setRGB(red3 / 255 * 0.3, green3 / 255 * 0.3, 0);

              leakChart.update();
              leakIndex++;
            } else {
              clearInterval(leakTimer); // 종료
            }
          }, 1000 / speedFactor);
        })
        .catch(error => {
          popupTitle.textContent = "오류";
          document.getElementById('popup-content').innerHTML = `<p style="color:#ff4d4d;">CSV 로드 실패: ${error}</p>`;
          popup.style.display = 'block';
        });
    }

    function Dispersion() {
      resetUI();
      document.querySelector('button[onclick="Dispersion()"]').classList.add('active');
      currentDemoDisplay.textContent = "암모니아 확산 양상";
      popupLocked = false;
      popup.style.display = 'none';
      
      // 기존 확산 관련 객체 제거
      scene.children.forEach(obj => {
        if (obj.userData && obj.userData.type === 'dispersion') {
          scene.remove(obj);
        }
      });
      
      // 파티클 배열 초기화
      const particles = [];
      
      // [1] 외부 박스 크기 정의
      const boxWidth = 13.8;
      const boxHeight = 21.5;
      const boxDepth = 7.5;
      const halfW = boxWidth / 2;
      const halfH = boxHeight / 2;
      const halfD = boxDepth / 2;

      // [2] 외부 박스 그리기
      const outerBox = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      const outerEdges = new THREE.EdgesGeometry(outerBox);
      const outerMaterial = new THREE.LineBasicMaterial({ color: 0x00CFE8, opacity: 0.7, transparent: true });
      const outerWireframe = new THREE.LineSegments(outerEdges, outerMaterial);
      outerWireframe.userData.type = 'dispersion';
      scene.add(outerWireframe);

      // [3] 내부 장애물 정의 (center + size)
      const obstacles = [
        { center: new THREE.Vector3(3.5, -1, 2), size: new THREE.Vector3(2, 10, 3) },
        { center: new THREE.Vector3(-0.4, -1, 2), size: new THREE.Vector3(2, 10, 3) },
        { center: new THREE.Vector3(-4.3, -1, 2), size: new THREE.Vector3(2, 10, 3) }
      ];

      // min/max 계산 및 시각화
      obstacles.forEach(obs => {
        const halfSize = obs.size.clone().multiplyScalar(0.5);
        obs.min = obs.center.clone().sub(halfSize);
        obs.max = obs.center.clone().add(halfSize);

        const geom = new THREE.BoxGeometry(obs.size.x, obs.size.y, obs.size.z);
        const edges = new THREE.EdgesGeometry(geom);
        const mat = new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 0.7, transparent: true });
        const wire = new THREE.LineSegments(edges, mat);
        wire.position.copy(obs.center); // 중심 좌표 기준 위치
        wire.userData.type = 'dispersion';
        scene.add(wire);
      });

      // 9개 그리드 정의 (3x3 → x,z 방향 분할)
      // ✅ XY 평면상 그리드 설정
      const gridCountX = 3;
      const gridCountY = 3;
      const gridWidth = boxWidth / gridCountX;
      const gridHeight = boxHeight / gridCountY;

      const gridPlanes = [];
      for (let i = 0; i < gridCountX; i++) {
        for (let j = 0; j < gridCountY; j++) {
          const material = new THREE.MeshBasicMaterial({
            color: 0x00CFE8,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide
          });
          const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(gridWidth, gridHeight),
            material
          );
          // XY 평면 → 회전 없음
          plane.position.set(
            -halfW + gridWidth * (i + 0.5),
            -halfH + gridHeight * (j + 0.5),
            -halfD + 0.01  // XY 평면에 z 고정
          );
          plane.userData.type = 'dispersion';
          scene.add(plane);
          gridPlanes.push({ mesh: plane, count: 0 });
        }
      }
      
      // [4] 누출원 위치
      const leakSource = new THREE.Vector3(4.8, 2.0, 0.4);
      
      // 누출원 시각화
      const sourceGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const sourceMaterial = new THREE.MeshStandardMaterial({
        color: 0xff4500,
        emissive: 0xcc3700,
        emissiveIntensity: 0.5,
        metalness: 0.3,
        roughness: 0.4
      });
      const sourceMesh = new THREE.Mesh(sourceGeometry, sourceMaterial);
      sourceMesh.position.copy(leakSource);
      sourceMesh.userData.type = 'dispersion';
      scene.add(sourceMesh);

      // [5] 파티클 설정
      const maxParticles = 1000;
      const interval = 100;
      const speed = 0.02;
      const maxAge = 100.0;

      function createParticle() {
        const direction = new THREE.Vector3(
          Math.random() * 2 - 1,
          Math.random() * 2 - 1,
          Math.random() * 2 - 1
        ).normalize();

        const material = new THREE.MeshBasicMaterial({
          color: 0xff4500,
          transparent: true,
          opacity: 0.6
        });

        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 6, 6),
          material
        );
        particle.position.copy(leakSource);
        particle.userData = {
          direction,
          age: 0,
          type: 'dispersion'
        };
        scene.add(particle);
        particles.push(particle);
      }

      const particleInterval = setInterval(() => {
        if (particles.length < maxParticles) createParticle();
      }, interval);

      function animateDispersion() {
        if (!scene.getObjectByName(sourceMesh.uuid)) {
          // 확산 시뮬레이션이 중단된 경우
          cancelAnimationFrame(dispersionFrameId);
          clearInterval(particleInterval);
          return;
        }
        
        dispersionFrameId = requestAnimationFrame(animateDispersion);

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          const delta = p.userData.direction.clone().multiplyScalar(speed);
          const nextPos = p.position.clone().add(delta);

          // [6-1] 외부 박스 반사
          if (Math.abs(nextPos.x) > halfW) {
            p.userData.direction.reflect(new THREE.Vector3(1, 0, 0));
            p.position.x = Math.sign(p.position.x) * halfW;
          }
          if (Math.abs(nextPos.y) > halfH) {
            p.userData.direction.reflect(new THREE.Vector3(0, 1, 0));
            p.position.y = Math.sign(p.position.y) * halfH;
          }
          if (Math.abs(nextPos.z) > halfD) {
            p.userData.direction.reflect(new THREE.Vector3(0, 0, 1));
            p.position.z = Math.sign(p.position.z) * halfD;
          }

          // [6-2] 내부 장애물 반사
          for (const obs of obstacles) {
            if (
              nextPos.x > obs.min.x && nextPos.x < obs.max.x &&
              nextPos.y > obs.min.y && nextPos.y < obs.max.y &&
              nextPos.z > obs.min.z && nextPos.z < obs.max.z
            ) {
              const entry = p.position;

              const distToMin = entry.clone().sub(obs.min);
              const distToMax = obs.max.clone().sub(entry);
              const absMin = new THREE.Vector3(Math.abs(distToMin.x), Math.abs(distToMin.y), Math.abs(distToMin.z));
              const absMax = new THREE.Vector3(Math.abs(distToMax.x), Math.abs(distToMax.y), Math.abs(distToMax.z));

              const minDist = Math.min(
                absMin.x, absMin.y, absMin.z,
                absMax.x, absMax.y, absMax.z
              );

              let normal = new THREE.Vector3(0, 0, 0);
              if (minDist === absMin.x) normal.set(-1, 0, 0);
              else if (minDist === absMax.x) normal.set(1, 0, 0);
              else if (minDist === absMin.y) normal.set(0, -1, 0);
              else if (minDist === absMax.y) normal.set(0, 1, 0);
              else if (minDist === absMin.z) normal.set(0, 0, -1);
              else if (minDist === absMax.z) normal.set(0, 0, 1);

              p.userData.direction.reflect(normal);
            }
          }

          // 위치 이동
          p.position.add(p.userData.direction.clone().multiplyScalar(speed));

          // [7] 색상 및 투명도 변화
          p.userData.age += speed * 5;
          const t = Math.min(p.userData.age / maxAge, 1);
          const r = 1;
          const g = t < 0.5 ? t * 2 : 1;
          const b = 0;
          const alpha = t < 0.5 ? 0.6 : 0.6 * (1 - (t - 0.5) * 2);

          p.material.color.setRGB(r, g, b);
          p.material.opacity = alpha;

          // [8] 수명 초과 시 제거
          if (p.userData.age > maxAge) {
            scene.remove(p);
            particles.splice(i, 1);
          }

          // 그리드별 입자 수 초기화
          gridPlanes.forEach(g => g.count = 0);

          // XY 평면 기준으로 입자 분포 카운팅
          particles.forEach(p => {
            const px = p.position.x + halfW;
            const py = p.position.y + halfH;

            const i = Math.floor(px / gridWidth);
            const j = Math.floor(py / gridHeight);

            if (i >= 0 && i < gridCountX && j >= 0 && j < gridCountY) {
              const index = i * gridCountY + j;
              gridPlanes[index].count++;
            }
          });

          // 최댓값 계산
          const counts = gridPlanes.map(g => g.count);
          const maxCount = Math.max(...counts);
          const minCount = Math.min(...counts);

          // 색상 업데이트 (초록 → 빨강)
          gridPlanes.forEach(g => {
            const t = maxCount > 0 ? (g.count - minCount) / (maxCount - minCount || 1) : 0;
            const r = t;
            const gVal = 1 - t;
            const b = 0.3 * (1 - t); // 약간의 파란색 추가로 시안색 효과
            g.mesh.material.color.setRGB(r, gVal, b);
          });
        }
      }

      let dispersionFrameId = requestAnimationFrame(animateDispersion);
    }

    let isDragging = false, offsetX = 0, offsetY = 0;

    popupHeader.addEventListener('mousedown', (e) => {
      if (e.target.tagName.toLowerCase() === 'button') return; // 버튼 클릭 시 드래그 방지
      isDragging = true;
      const rect = popup.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        popup.style.left = (e.clientX - offsetX) + 'px';
        popup.style.top = (e.clientY - offsetY) + 'px';
        popup.style.transform = 'none'; // 드래그 시 transform 제거
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('resize', () => {
      const container = document.getElementById('viewer');
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    window.addEventListener('click', (event) => {
      // 1. UI 요소면 raycaster 검사 생략
      if (
        event.target.closest('#popup') ||
        event.target.closest('#overlay-buttons') ||
        event.target.closest('#info-panel')
      ) return;

      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableCubes);

      if (intersects.length > 0) {
        // 정상 클릭 시 팝업 표시
        const obj = intersects[0].object;
        const name = obj.userData.name;
        const imgPath = obj.userData.image || 'default.png';

        const html = `
          <div style="text-align: center; margin-bottom: 15px;">
            <img src="${imgPath}" alt="${name}" style="width:90%; max-height:200px; object-fit:contain; margin-top:5px; border-radius:8px; border:1px solid rgba(0,207,232,0.3);">
          </div>
          <div style="background: rgba(0,207,232,0.1); padding:10px; border-radius:8px; border:1px solid rgba(0,207,232,0.2);">
            <h3 style="margin-top:0; color:#00CFE8; font-size:1rem;">${name} 정보</h3>
            <p>위치: (${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)})</p>
            <p>상태: <strong>정상</strong></p>
            <p>측정값: <strong>0.42 ppm</strong></p>
          </div>
        `;
        popupTitle.textContent = name;
        document.getElementById('popup-content').innerHTML = html;
        popup.style.display = 'block';
        popup.style.top = '10%';
        popup.style.left = '50%';
        popup.style.transform = 'translateX(-50%)';
        popupLocked = false;

      } else {
        if (!popupLocked) popup.style.display = 'none';  // 잠금된 팝업은 닫히지 않음
      }
    });

    window.addEventListener('mousemove', (event) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableCubes);

      if (intersects.length > 0) {
        if (INTERSECTED != intersects[0].object) {
          if (INTERSECTED) {
            INTERSECTED.material.color.set(0x00CFE8); // 원래 색으로
            INTERSECTED.material.emissive.set(0x006774);
          }
          INTERSECTED = intersects[0].object;
          INTERSECTED.material.color.set(0xffff00); // hover 시 노란색
          INTERSECTED.material.emissive.set(0x555500);
          
          // 마우스 오버 시 센서 정보 표시
          document.getElementById('sensorInfo').textContent = `${INTERSECTED.userData.name} 위치: (${INTERSECTED.position.x.toFixed(2)}, ${INTERSECTED.position.y.toFixed(2)}, ${INTERSECTED.position.z.toFixed(2)})`;
        }
      } else {
        if (INTERSECTED) {
          INTERSECTED.material.color.set(0x00CFE8);
          INTERSECTED.material.emissive.set(0x006774);
          INTERSECTED = null;
          document.getElementById('sensorInfo').textContent = "센서를 클릭하면 정보가 표시됩니다.";
        }
      }
    });

    // 센서 추가
    addLabeledCube(3.45, 1.11, -0.565, 'Sensor #1', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-0.507, 1.11, -0.565, 'Sensor #2', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-4.46, 1.11, -0.565, 'Sensor #3', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(4.26, 1.11, 0.360, 'Sensor #4', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(0.304, 1.11, 0.360, 'Sensor #5', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
    addLabeledCube(-3.65, 1.11, 0.360, 'Sensor #6', 1, 'https://raw.githubusercontent.com/Jaehui-Jeong/TestSources/refs/heads/main/images/test_image.png');
  </script>
</body>
</html>
